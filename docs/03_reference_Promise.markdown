Python PromiseKeeper Reference
==============================

This is the main reference documentation for the promise\_keeper module.  The
source maintains more up to date documentation in docstrings.  Check pydocs
for more information.


Class Promise
-------------
A _Promise_ is a reference to the work you have submitted to a _PromiseKeeper_
instance.  It is used to track what was submitted and the status of the work.
_Promises_ are normally generated by the _PromiseKeeper_ in response to a
_submit_ request.

    from promise_keeper import PromiseKeeper
    pk = PromiseKeeper()

    # Method 1
    promise = pk.submit(lambda x: x*0.5, (50,))

    # Method 2
    primise2 = Promise(lambda x: x*2, (25,))
    pk.submit_promise(promise)
    while not promise.is_ready()
        pass
    print promise


### Constructor Arguments ###

There are two ways to create a Promise.  The first way is to use the _submit_
method of a PromiseKeeper instance.  The _submit_ method will construct a
Promise, submit it to the work queue and then return it to the caller.

The other way to create a Promise is to use the Promise classes constructor.
This doesn't schedule it to be worked on by any given PromiseKeeper.  You still
need to submit it to a PromiseKeeper instance using it's _submit\_promise_
method.

That said, here are the Promise constructor's arguments:

__task__ - This should be a callable that will be executed by a PromiseKeeper
instance.  This argument is mandatory.

__args__ - This should be a list or tuple of arguments that will be passed to
the task.  This argument it optional and defaults to an empty list.

__kwargs__ - This should be a dictionary of kwargs that will be passed to the
task.  This argument is optional argument and default to an empty dictionary.

__notify__ - This should be a callable that takes a single argument.  The
PromiseKeeper that executes your task will call _notify_ with the Promise
it executed when the task is done.  This argument is optional.

    promise_1 = Promise(lambda x: x*x, (25,))

    def promise_done(promise):
        print promise.get_result()

    promise_2 = Promise(notify=promise_done, task=calculate_pi)

    def get_longest(item_1='', item_2=''):
        if len(item_1) > len(item_2):
            return item_1
        else:
            return item_2

    promise_3 = Promise(task=get_longest, kwargs={ \
        'item_1': 'Python', 'item_2': 'rocks'})


### Methods ###

Promises have the following methods:

__is\_ready()__ - Returns _True_ if processing of the task has been completed.
Returns _False_ otherwise.

__has\_started()__ - Returns _True_ if processing has begun on the requested
task.  Returns _False_ if the task is still waiting in queue.

__get\_task__() - Returns a reference to the task that the Promise was created
with.

__get\_args__() - Returns a reference to the args that the Promise was created
with.

__get\_kwargs__() - Returns a reference to the kwargs that the Promise was
created with.

__get\_execution\_time()__ - If processing of the task has completed, this
method returns the length of time it took to perform the task.  If the task
has __not__ completed, this method returns _None_.

__get\_started\_on()__ - Returns the datetime the task began execution.  If it
hasn't begin executing, this method returns _None_.

__get\_completed\_on()__ - Returns the datetime the task completed.  If it
hasn't completed or hasnt' even begun, this method will return _None_.

__get\_result()__ - Returns the result (return value) of the task.  If the
task hasn't completed or completed, but raised an Exception, the method will
return _None_.

__get\_exception()__ - If the task raised an Exception, this method will
return that Exception.  If the task completed successfully or hasn't even
started, this method will return _None_.

__then\_do(task)__ - Use this method to chain one promise to another.  When
__then\_do__ is called on a Promise (Promise-A), a new Promise (Promise-B) is
created using the given __task__.  __task__ is a callable that takes a Promise
as an argument.  When Promise-A is completed, Promise-B will be submitted to
the work queue.  Promise-B will be the argument to Promise-A.  The example
below will illustrate chaining.

    from promise_keeper import PromiseKeeper

    def read_file(filename):
        return open(filename).read().strip()

    def convert_to_records(promise):
        if promise.get_exception():
            raise promise.get_exception()
        data = promise.get_result()
        return [line.split(",") for line in data.split("\n")]

    def get_first_column(promise):
        if promise.get_exception():
            raise promise.get_exception()
        data = promise.get_result()
        return [record[0] for record in data]

    pk = PromiseKeeper(auto_start=False)

    p = pk.submit(read_file, ('data.txt',)) \
        .then_do(convert_to_records) \
        .then_do(get_first_column)

    pk.start()
    while not p.is_ready(): pass

    if p.get_exception():
        print p.get_exception()
    else:
        for col in p.get_result():
            print col



Copyright (c) 2017, Steve Brettschneider.
License: MIT (see LICENSE for details)
